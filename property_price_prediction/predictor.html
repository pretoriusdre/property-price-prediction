<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Property Price Predictor</title>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
  <h1>Property Price Predictor</h1>



    <h1>THIS IS CURRENTLY BROKEN USE THE PYTHON VERSION</h1>


  <input type="file" id="fileInput" />
  <button onclick="trainModel()">Train Model</button>

  <div id="formSection" style="display:none; margin-top:20px;">
    <h3>Enter Property Details</h3>
    <label>Data Model:
      <select id="dataModelSelect"></select>
    </label><br><br>
    <label>Bedrooms: <input type="number" id="bed" /></label><br><br>
    <label>Bathrooms: <input type="number" id="bath" /></label><br><br>
    <label>Car Spaces: <input type="number" id="car" /></label><br><br>
    <label>Land Area (sqm): <input type="number" id="land" /></label><br><br>
    <label>Date (YYYY-MM-DD): <input type="date" id="date" /></label><br><br>
    <label>Desirability (1-10): <input type="number" id="desirability" min="1" max="10" /></label><br><br>
    <button onclick="makePrediction()">Predict Price</button>
    <p id="predictionResult"></p>
  </div>

  <script>
    class LinearRegression {
      constructor(X, y) {
        const XT = this.transpose(X);
        const XTX = this.multiply(XT, X);
        const XTy = this.multiply(XT, y);
        const XTXInv = this.inverse(XTX);
        this.weights = this.multiply(XTXInv, XTy).flat();
      }

      predict(X) {
        return X.map(row => row.reduce((sum, val, i) => sum + val * this.weights[i], 0));
      }

      transpose(matrix) {
        return matrix[0].map((_, i) => matrix.map(row => row[i]));
      }

      multiply(A, B) {
        const result = Array(A.length).fill(0).map(() => Array(B[0].length).fill(0));
        for (let i = 0; i < A.length; i++) {
          for (let j = 0; j < B[0].length; j++) {
            for (let k = 0; k < B.length; k++) {
              result[i][j] += A[i][k] * B[k][j];
            }
          }
        }
        return result;
      }

      inverse(matrix) {
        const n = matrix.length;
        const I = matrix.map((row, i) => row.map((_, j) => (i === j ? 1 : 0)));
        for (let i = 0; i < n; i++) {
          let factor = matrix[i][i];
          for (let j = 0; j < n; j++) {
            matrix[i][j] /= factor;
            I[i][j] /= factor;
          }
          for (let k = 0; k < n; k++) {
            if (k !== i) {
              const factor2 = matrix[k][i];
              for (let j = 0; j < n; j++) {
                matrix[k][j] -= factor2 * matrix[i][j];
                I[k][j] -= factor2 * I[i][j];
              }
            }
          }
        }
        return I;
      }
    }

    class PropertyPricePredictor {
      constructor() {
        this.FEATURES_TO_USE = ['bed', 'bath', 'car', 'land', 'days_since_epoch', 'desirability'];
        this.EPOCH_DATE = new Date('2000-01-01');
        this.models = {};
        this.df = [];
        this.statsByModel = {}; // hold normalization stats per model
      }

      getDaysSinceEpoch(dateStr) {
        const date = new Date(dateStr);
        return Math.floor((date - this.EPOCH_DATE) / (1000 * 60 * 60 * 24));
      }

      async loadFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (evt) => {
            const data = new Uint8Array(evt.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const json = XLSX.utils.sheet_to_json(firstSheet);
            resolve(json);
          };
          reader.onerror = reject;
          reader.readAsArrayBuffer(file);
        });
      }

      async loadData(file) {
        this.df = await this.loadFile(file);
        this.df.forEach(row => {
          row.days_since_epoch = this.getDaysSinceEpoch(row.date);
        });
      }

      buildModels() {
        const groups = this.df.reduce((acc, row) => {
          if (!acc[row.data_model]) acc[row.data_model] = [];
          acc[row.data_model].push(row);
          return acc;
        }, {});

        for (const [modelName, rows] of Object.entries(groups)) {
          const cleanRows = rows.map(row => {
            const filled = {};
            for (const key of this.FEATURES_TO_USE) {
              filled[key] = row[key] != null ? row[key] : this.getMode(rows, key);
            }
            filled.price = row.price;
            return filled;
          });

          const { normalizedRows, stats } = this.normalizeFeatures(cleanRows);
          this.statsByModel[modelName] = stats;

          const X = normalizedRows.map(r => this.FEATURES_TO_USE.map(f => r[f]));
          const y = normalizedRows.map(r => [r.price]);

          const model = new LinearRegression(X, y);
          this.models[modelName] = model;
        }

        return Object.keys(this.models);
      }

      normalizeFeatures(rows) {
        const stats = {};
        for (const key of this.FEATURES_TO_USE) {
          const values = rows.map(r => r[key]);
          const mean = values.reduce((a, b) => a + b, 0) / values.length;
          const std = Math.sqrt(values.reduce((sum, v) => sum + (v - mean) ** 2, 0) / values.length);
          stats[key] = { mean, std };
        }

        const normalizedRows = rows.map(row => {
          const normRow = {};
          for (const key of this.FEATURES_TO_USE) {
            const { mean, std } = stats[key];
            normRow[key] = std === 0 ? 0 : (row[key] - mean) / std;
          }
          normRow.price = row.price;
          return normRow;
        });

        return { normalizedRows, stats };
      }

      getMode(rows, feature) {
        const counts = {};
        for (const row of rows) {
          const val = row[feature];
          if (val != null) counts[val] = (counts[val] || 0) + 1;
        }
        return Object.entries(counts).reduce((a, b) => (b[1] > a[1] ? b : a))[0];
      }

      predict(parameters) {
        const model = this.models[parameters.data_model];
        if (!model) throw new Error(`Model not found: ${parameters.data_model}`);

        parameters.days_since_epoch = this.getDaysSinceEpoch(parameters.date);

        const stats = this.statsByModel[parameters.data_model];
        const input = [this.FEATURES_TO_USE.map(f => {
          const { mean, std } = stats[f];
          return std === 0 ? 0 : (parameters[f] - mean) / std;
        })];

        const prediction = model.predict(input)[0];
        return Math.round(prediction);
      }
    }

    const predictor = new PropertyPricePredictor();
    let selectedFile = null;

    document.getElementById('fileInput').addEventListener('change', (e) => {
      selectedFile = e.target.files[0];
    });

    async function trainModel() {
      if (!selectedFile) {
        alert("Please select a file first.");
        return;
      }
      await predictor.loadData(selectedFile);
      const models = predictor.buildModels();
      populateModelDropdown(models);
      document.getElementById('formSection').style.display = 'block';
    }

    function populateModelDropdown(models) {
      const select = document.getElementById('dataModelSelect');
      select.innerHTML = '';
      models.forEach(model => {
        const option = document.createElement('option');
        option.value = model;
        option.textContent = model;
        select.appendChild(option);
      });
    }

    function makePrediction() {
      try {
        const params = {
          data_model: document.getElementById('dataModelSelect').value,
          bed: parseInt(document.getElementById('bed').value),
          bath: parseInt(document.getElementById('bath').value),
          car: parseInt(document.getElementById('car').value),
          land: parseFloat(document.getElementById('land').value),
          date: document.getElementById('date').value,
          desirability: parseFloat(document.getElementById('desirability').value)
        };

        const result = predictor.predict(params);
        document.getElementById('predictionResult').textContent = `Predicted price: $${result.toLocaleString()}`;
      } catch (err) {
        alert(err.message);
      }
    }
  </script>
</body>
</html>
